# Crypto CTF 2024
##  Jonon | Tough | 247 pts

Task description:

```
The Jonon challenge is a variation of the Imen challenge, and it provides a similar level of difficulty as the original version - it's an enjoyable experience.
```

Attachments:

```python
#!/usr/bin/env sage

from Crypto.Util.number import *
from string import printable as prn

def genimen(k, p, _B):
	while True:
		A = random_matrix(GF(p), k)
		for i in range(k):
			for j in range(k):
				A[i, j] = int(A[i, j]) % (_B + 1)
		if det(A) != 0: return A

def genkey(k, p, _B, l):
	sA = [genimen(k, p, _B) for _ in range(l + 1)]
	L = list(range(l))
	shuffle(L)
	s, pE = randint(1, p - 1), prod([sA[_] for _ in L])
	sD, sE = sA[-1], s * pE
	pkey = [sE * _ * sD * sE.inverse() for _ in sA[:-1]], sA[:-1], pE
	skey = L, s, sE, sD
	return pkey, skey

def encrypt(pkey, _p):
	pA, psA, pE = pkey
	k = pA[0].nrows()
	C = identity_matrix(GF(p), k)
	for i in _p: C *= pA[i]
	return C

nbit = 256
k, l, p, _B = 5, 19, getPrime(nbit), 63
_p = list(range(l))
shuffle(_p)
flag = 'CCTF{' + ''.join([prn[10 + _p[_]] for _ in range(l)]) + '}'

pkey, skey = genkey(k, p, _B, l)
C = encrypt(pkey, _p)
print(f'pkey = {pkey}')
print(f'C = {C}')
````

And [output.txt](./output.txt) that is of the following format:

```
....

[ 4976294010363997894507580835130681719219749898455372695841816988558831931582 46450753239721218641438568089656254893821946067547065136426973602910238362705  6580471846343333748071354479292372122906948858331240722093456456780198587849 60396517155271013803104683899354910720364450006384746231605715824149404876160 33738587082296135244061395724642444800010908645184205903240961198446141057758]], [[14 51 10 55 11]
[45 30 13 40 29]
[22 44 50 39 34]
[48 12 33  8  9]
[ 5 55 21 51 36], [62 63 16 11 14]
[20  9 61 41 25]

...
```

Yes. It's the default sage matrix output format. **Please, don't do this**. It's weird. We have to parse it.

## Solution

The setup is pretty similar to `imen` chal. We have some matrix permuted products and we have to recover the permutation. Now it overflows. And we still don't know $p$, but now we need it.

Special thanks to my friend **@defkit** for preparing it for me


```python
with open('output_hr.txt', 'r' ) as f:
    data = f.read()

def parse_line(line):
    line = line.replace('[', '').replace(']', '')
    line = line.split(' ')
    line = list(filter(lambda a: a != '', line))
    return list(map(int, line))

def parse_all_matricies():
    matricies = []
    m = []
    for line in data.split('\n'):
        if line == '':
            matricies.append(m)
            m = []
            continue
        m.append(parse_line(line))
    return matricies

matricies = parse_all_matricies()[:-1]
C = Matrix(ZZ, matricies[-1])
pkey = [Matrix(m) for m in matricies[:-1]]

pA = pkey[:19]
psA = pkey[19:38]
pE = pkey[-1]
```

Let's break it down a little. 

First we have `pE` which is simply the product of the permuted matrices. We know them all, they're in `psA` list.

$pA_i = s * pE \times A_i \times A_{19} \times (s * pE)^{-1}$ where `s` is the secret that we don't know of that serves as a mask for the product of small matrices. 

However as we can see on the left we have `s` and on the right $(s * pE)^{-1}$ which is of course $\frac{1}{s} * pE^{-1}$. So this value will be disintegrated. 

What we're left with is $ pE \times A_i \times A_{19} \times pE^{-1}$ over  $F_p$. And it overflows. A lot. Here's one of them:


```python
pA[0]
```




    [16993475031585001836152674491429921937799217140125011348387575447154670636383 29061009558277282696673138706665305979482540128353753141455786245622571916721 20391244334945160828113513071381528563868623936292070347638870904277587032144  2073229435995749796767583417197806042410714014216575463528679497147124200713  1437053216441297378844655977811450301318478116050753478532658204818376139523]
    [30229080423420500554840080818322776102333227164007085767550402896385265870183 29628843370959726613697973364512776369143924540832643185474236669135075347730 10466583421321831648378355394811686075199103904687903732918970293241428478364 21377742294854340161924421420345014389875632676004477969969914106151503247285 26606194691528325015163809918722371057840857530463865740846904378281324226527]
    [45971491668353383548700311096044004797282323706089696032551513368213744297675 29939721312969746889079505991946347395567604318060163659548354339026005301318 57029838204373937455756779375949446983373743311828383072316812276869205746887 59847594171129803661432996510323591561413569928675656958413658379728418714846 54509309476081957768166026808747456409644079252404306465651161423148940634009]
    [14584585989238099931217070864234375818330290266516878163070068771347048250592 57365726764629982324721102533783158843515688658883820202318320737389567319490 12958017098371929967387471989802879280146623153315174016402683067032866322798 63615078354338078052969298241399806916170956814054603497976816489607361125059 52615464533782133753268164891313444255430439957367976285630807759374903068460]
    [55196965448026878617027067276109879194907415904581428195208064586961456579747 43507279478580470252843235788318639022902301119646365251763195501382816615344 20594643240312552587156528730153431894768896142022086673310475749579407820352 30854294166027460115299147465575296337269545627260046882933449029337068209516 36950562084319128773475954433737172415779802416705143080943533618174642222066]



However, the thing is. We know $pE$ and we know $A_i$. Maybe we do not know $A_{19}$ but all 19 terms contain this unknown. 

Also, now we will work over rational field, however all the features of the finite filed will stay with these numbers. And they will remain pretty once you reduce everything $\pmod{p}$

So let's take a look at those matrices over $\mathbb{Q}$:


$(pE \times A_i)^{-1} \times pA_i \times pE = A_{19} \pmod{p}$ for each $i$. 

Thus, since all these terms will not be the same over $\mathbb{Q}$, we can extract the prime using `gcd`


```python
equivalences = [[] for _ in range(25)]
for i, pa in enumerate(pA):
    tmp = (pE * psA[i]).change_ring(QQ)^-1 * pa.change_ring(QQ) * pE.change_ring(QQ)
    for a in range(5):
        for b in range(5):
            equivalences[a * 5 + b].append(tmp[a][b])

print(equivalences[0])
```

    [-87580655094756592748093696535893306660730804237130286644563560507659963701864373944723934083953121818016423468382001955944087205531014743249926368774726735797881455967038466358848889082867634405693502602128633435589845229009759875657107/13429758896115210998738105252502577235785933354060295426038236957192135582233416261341754073826191910804483925178378003876818452480000000, 137475598102604794111857910100798657129933203013868208118636260430666339246529321070944151248523875630305699290540921744348281664144870583910999233725417565829388735125941400779024502518277592707310184104747835085818120427196264781598518327/2251164565830807572208130530603700298602635295786888476738389190655861990782354479086046446626855374300745826865959706377851648000000000000, -416989111064278883380772686963787466890131856675275380476307528057852715127481555362718386976794653767483971208566019575803635821193191781585670384331450193510056615836793768637928469888212334203415455010109193022017390263246702669159457483/2835457185888934692615654585364297659727024198963718448358546788274720765120327683125645493971267471758074733969772668617137565696000000000, 63655999885917120266379121345842187751068926355894853422556249608316757028036387301380472582446653119201719736492843538427173028464289593238232468978985093586897606598962010492737190821172443665548005748385023803337525027933154716366306783/1162403828438685330405662615509266184224072471614948452704347999536225507759298884537270083477291355798871507815696985857011886571520000000, 117857469808787161890055283916802357667705951111818856494792267900189500822157835649417457917954022875305245115856271484314967467146591072340949303315706241957325632458068541484203580086717314633169125846605546670011412923147983193730279/2163211268223834411154637928789922926779422620271724523268421573565524810634431292622896014286792696265205939218008157335413169192960000000, 55030917201287944967279798708742562999028478684868843418597408138238518733362627347519449557702671342418522197670337864591177213566415751471738251213080568444929568441931280891071956796486807524533055500990090813656049867318492169845360297/186744343870939407067151441573369078101442290891283410867953978028420049230059764841125211114081967678617356612391417250564143513600000000, 460163689820166717487355367198931467321967697235435230507986511403667118825157276965776102701783718684354336101363888549634725275497036166667008599320293154544878033481148428325182378716656445319192805457452193524467658892920242479033079/12737038884241732059872711167157302704723898458215608739577409785952575701885926541879610917351806261533921976550894979436685308108800000000, 6940423443879504072453821853860232607128001930895068086414922731831198342024746223691003718788187999097256186174255004713897971590475403807778438937007053132700966746642817693672544759760927778216702343576991279932055908477882944374997661/136611033954741722272056553249541513767745918711585607920225593774347608457286950041707065420138557717422060301181032943264408422400000000, -3865485299051336611279303909680373400221291691826606980918054753685582265226907521311092945667110677776160791592413630708504118570624625710750826638027787820248191914792263527830908640845745960172929428031053864536654474631501971665744889/224122368493359731959223080977285027388839054738775007156723635358858490132364074074897603721043523528734636252304744008965684510720000000, 32881105981561262184616844616860439598216570279069634492315045787670750880834794048730098131422542754813777771992873529482717965749050853800383336994433936058539376879485083876612956030217944371559153730974487610759022813952652274450427/1346561268401864850810220476462518764094156205331841566840350372177552756632950666281255028674234171284501113916088433151131238400000000, -16123429005564774350611721938729852004555672848258820358323535227500463876722783789490735155744657810844424569819636546899293879631658469236154580189990919481073344122282920781883428250825400813662079468627782166556425847908103202059332637/139206379511419343749225715313567708102075035509092832285424176715946981430780588213039364241654024491049704795218618821052482846720000000, 567827043033168710433734663116432938223176390344129057514417257707456795012857848861612990243946943352417594769257162743980252568253933432553112659105266266350700794784969215609953162238797946630966228271540065680532141821865523252631207/6049683607031259131357935338992334978690088260563973924975903662505016861002395463300750074077906056768623580370709970631178649600000000, 1329555605164704828214103432505259907351816708013345394610263930401545773664955585165625414167816957827493465883570574327169005762928539125572398142768146457635378300565626786818783686544747399877575779148832471859923382881908088424644807/1728239091230863245699629137442174234265821276627901536450480294258953023441796593037703822185892022389916272887306483166684203057152000, 293055313116126678005428589035704001101602455690074223882252091927895681487302421521913145576738868007453222796594858634799846116090381088301925295553324991413884921374043141570650101154646282714637753207717443435417156707103516277032219411/25797794635070948187477935425907514178863703634927533216736928287773467997387012934672204967747205452515809027291739889138687812812800000000, 50295610025632468840066186247412112384771447957136122540986542891973203735213381325364564985656873285793929043529238769666505437238184688093566449088265126367847718001002705824570594616534200474481013734206201606094523472031026625779785367/8585984018620150691599798366386085168639240443780534711160506219044030127609103024807251414168213305239444012441533533025801297100800000000, 42389994594619654624387564402633413090178984878611368987849084622555971615195748163022852491121866980213150114520899560187611963519189184345945561926543348785791670558846527373693197576695661122101454142621972531898772188708316333277243111/23253737659549641647541450666879976852404454613939404151807486795188208407529929769606516700523037576696701937333825710395655190937600000000, -2986000883109540465082711199928224143228271461797282082911104398939979925203481857068801343875123707716205515044917579948052168740360839656257020620873421015967811830465343691720481295339414265930200125170693907283030237327509826752409861/8729289209723481258977550969957906750389804528915520725517831888884902252655830565197216726104683671419900407813990793324487065600000000, 5933472769922557614667312265901019029276835438560741692474978995927849251314016401780558837802561873720356819077445780241755635694694146905752891228954747981258129851686880150236589086864533347625262167866594360386298330021901446322796183/45190256705703173650660455926970464915925598866146480963626704366368528776010405768297700720636160901964917152932792964723689062400000000, 11629863635940094597650770555956687551296305157907779643237655018825062243311895941825065708198615505982092880343983326998553743013185283988035242834328162114818396609519551577211523072991649419904524095081755147287507466231815275546115739/455299301441399087725519369068005685346333852855195199021981473631120185459421555730343944970294827459437437695033882266872392960000000000]


In each `equivalences` cell there's a list of the numbers that have the same remainder $\pmod{p}$;

By taking sevral fractions: $\frac{a_1}{b_1} = \frac{a_2}{b_2} \pmod{p}$ this is equivalent to $a_1 * b_2 - b_1 * a_2 = 0 \pmod{p}$ and we have a lot of them to fully recover p.


```python
gcd_base = [(x1 - equivalences[0][0]).numerator() for x1 in equivalences[0][1:]]
gcd(gcd_base)
```




    68072599015191957577350893302343041540755881407848594728366324833646985020777




```python
p = 68072599015191957577350893302343041540755881407848594728366324833646985020777
is_prime(p)

A19 = (pE * psA[0]).change_ring(GF(p))^-1 * pA[0] * pE
A19
```




    [22 25 38 59 47]
    [47 30 16 29  1]
    [47  7 12  3 23]
    [ 8  0 12  2 17]
    [56 24  8 12 23]



And we succesfully recovered the prime number. And $A_{19}$!

Now we need to do the same thing that we did in `imen`. However, after looking closely at matrix products I noticed that if we use all but one of the matrices we stay in integer space, so we can simply guess the first value and then proceed as early. Thanks [uvicorn](https://t.me/lasagnahowto) for that.


```python
def get_permutation(ms, tmpm, perm):
    print(perm)
    if len(perm) == len(ms):
        if tmpm.is_one():
            return perm
        return None

    for i in range(len(ms)):
        if i not in perm:
            t1 = A19.change_ring(QQ)**-1 * ms[i]**-1
            m1 = tmpm * t1
            if (all(x.is_integer() for y in m1 for x in y)):
                res = get_permutation(ms, m1, [i] + perm)
                if res is not None:
                    return res
    return None
```


```python
C1 = pE.change_ring(GF(p))^-1 * C * pE

for i in range(len(psA)):
    C2 = C1 * A19**-1 * psA[i].change_ring(GF(p))**-1
    get_permutation(psA, C2.change_ring(QQ), [i])
    print()
```

    [0]
    
    [1]
    
    [2]
    
    [3]
    
    [4]
    
    [5]
    
    [6]
    [1, 6]
    [4, 1, 6]
    [14, 4, 1, 6]
    [18, 14, 4, 1, 6]
    [11, 18, 14, 4, 1, 6]
    [8, 11, 18, 14, 4, 1, 6]
    [7, 8, 11, 18, 14, 4, 1, 6]
    [16, 7, 8, 11, 18, 14, 4, 1, 6]
    [2, 16, 7, 8, 11, 18, 14, 4, 1, 6]
    [5, 2, 16, 7, 8, 11, 18, 14, 4, 1, 6]
    [10, 5, 2, 16, 7, 8, 11, 18, 14, 4, 1, 6]
    [13, 10, 5, 2, 16, 7, 8, 11, 18, 14, 4, 1, 6]
    [9, 13, 10, 5, 2, 16, 7, 8, 11, 18, 14, 4, 1, 6]
    [3, 9, 13, 10, 5, 2, 16, 7, 8, 11, 18, 14, 4, 1, 6]
    [0, 3, 9, 13, 10, 5, 2, 16, 7, 8, 11, 18, 14, 4, 1, 6]
    [17, 0, 3, 9, 13, 10, 5, 2, 16, 7, 8, 11, 18, 14, 4, 1, 6]
    [15, 17, 0, 3, 9, 13, 10, 5, 2, 16, 7, 8, 11, 18, 14, 4, 1, 6]
    [12, 15, 17, 0, 3, 9, 13, 10, 5, 2, 16, 7, 8, 11, 18, 14, 4, 1, 6]
    
    [7]
    
    [8]
    
    [9]
    
    [10]
    
    [11]
    
    [12]
    
    [13]
    
    [14]
    
    [15]
    
    [16]
    
    [17]
    
    [18]
    



```python
perm = [12, 15, 17, 0, 3, 9, 13, 10, 5, 2, 16, 7, 8, 11, 18, 14, 4, 1, 6]
assert prod(pA[i] for i in perm).change_ring(GF(p)) == C
```


```python
from string import printable as prn
flag = 'CCTF{' + ''.join([prn[10 + perm[_]] for _ in range(19)]) + '}'
```


```python
flag
```




    'CCTF{mpradjnkfcqhilsoebg}'


